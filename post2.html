<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
    <meta name="description" content=""/>
    <meta name="author" content=""/>
    <title>specialjcg Blog</title>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico"/>
    <!-- Font Awesome icons (free version)-->
    <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
    <!-- Google fonts-->
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet"
          type="text/css"/>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
          rel="stylesheet" type="text/css"/>
    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="css/styles.css" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
          integrity="sha384-n0yhjrAMKb1vdA2CkWRHpOyRvNs2Vc1I5ksSTT6rl1fu3bU/HzOIVPB8kpxHtEv5" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-okaidia.min.css">

</head>
<body>
<!-- Navigation-->
<nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
    <div class="container px-4 px-lg-5">
        <a class="navbar-brand" href="index.html">SpecialJcg</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive"
                aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            Menu
            <i class="fas fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ms-auto py-4 py-lg-0">
                <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About</a></li>
                <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="post.html">Sample Post</a></li>
                <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="contact.html">Contact</a></li>
            </ul>
        </div>
    </div>
</nav>
<!-- Page Header-->
<header class="masthead" style="background-image: url('assets/img/Sélection_216.png')">
    <div class="container position-relative px-4 px-lg-5">
        <div class="row gx-4 gx-lg-5 justify-content-center">
            <div class="col-md-10 col-lg-8 col-xl-7">
                <div class="post-heading">
                    <h1>Remove Duplicates from Sorted Array</h1>
                    <h2 class="subheading">Essayons en Rust</h2>
                    <span class="meta">
                                Posted by
                                <a href="#!">SpecialJcg</a>
                                25 mars 2024
                            </span>
                </div>
            </div>
        </div>
    </div>
</header>
<!-- Post Content-->
<article class="mb-4">
    <div class="container px-4 px-lg-5">
        <div class="row gx-4 gx-lg-5 justify-content-center">
            <div class="col-md-10 col-lg-8 col-xl-7">
                <h1>Suppression des doublons dans un tableau</h1>
                <p>Étant donné un tableau d'entiers nums trié dans l'ordre croissant, supprimez les doublons sur place de manière à ce que chaque élément unique n'apparaisse qu'une seule fois. L'ordre relatif des éléments doit être conservé. Ensuite, retournez le nombre d'éléments uniques dans nums.</p>
                <p>Considérez le nombre d'éléments uniques de nums comme k, pour être accepté, vous devez faire ce qui suit :</p>
                <ol>
                    <li>Modifiez le tableau nums de sorte que les k premiers éléments de nums contiennent les éléments uniques dans l'ordre où ils étaient présents initialement dans nums. Les éléments restants de nums ne sont pas importants, tout comme la taille de nums.</li>
                    <li>Retournez k.</li>
                </ol>
                <ol>
                    <li>L'idée principale est de parcourir le tableau et de garder une trace de la position où insérer le prochain élément unique. Pour cela, nous comparons chaque élément avec le précédent et ne conservons que les éléments uniques.</li>
                    <li>Approche
                        <ol>
                            <li>Vérifier si le tableau est vide. Si c'est le cas, retourner 0 car il n'y a aucun élément unique.</li>
                            <li>Initialiser un indice k à 1, représentant la position où insérer le prochain élément unique. Nous commençons à 1 car le premier élément est déjà considéré comme unique.</li>
                            <li>Parcourir le tableau à partir de l'indice 1.</li>
                            <li>Pour chaque élément, comparer avec l'élément précédent (à l'indice k - 1). Si l'élément est différent, cela signifie qu'il est unique et doit être conservé.</li>
                            <li>Si l'élément est unique, le placer à la position k et incrémenter k pour pointer vers la prochaine position pour un élément unique.</li>
                            <li>À la fin de la boucle, k représente le nombre d'éléments uniques dans le tableau.</li>
                        </ol>
                    </li>
                    <li>Complexité
                        <ul>
                            <li>Complexité temporelle : O(n) où n est la taille du tableau. Nous devons parcourir le tableau une fois.</li>
                            <li>Complexité spatiale : O(1) car nous modifions le tableau en place sans utiliser de mémoire supplémentaire en dehors de quelques variables de comptage.</li>
                        </ul>
                    </li>
                </ol>


                <h3 id="1er-test">Test</h3>
                <div><p>Ces tests vérifient différents cas :</p>

                    <ol>
                        <li>Un cas où le vecteur est vide.</li>
                        <li>Un cas où aucun doublon n'existe.</li>
                        <li>Un cas où des doublons existent.</li>
                        <li>Un cas où tous les éléments sont des doublons.</li>
                    </ol>

                </div>
                <h4>Test avec un tableau vide (test_remove_duplicates_empty) :</h4>
                <pre><code class="language-rust">
#[cfg(test)]
mod tests{
    #[test]
    fn test_remove_duplicates_empty(){
        let nums:Vec<i32> =vec![];
        assert_eq!(remove_duplicates(&nums),0);
    }

    fn remove_duplicates(list_num: &Vec<i32>) -> i32 {
        if list_num.is_empty() {
            return 0;
        }
       return 1;
    }
}

        </code></pre>

                <p><i class="fas fa-circle" style="color: green;"></i> Dans ce test, le tableau est vide, donc la fonction doit simplement retourner 0, indiquant qu'il n'y a aucun élément unique dans le tableau. </p>

                <h4>Test sans doublons (test_remove_duplicates_no_duplicates) :</h4>

                <pre><code class="language-rust">
#[cfg(test)]
mod tests{
    #[test]
    fn test_remove_duplicates_empty(){
        let nums:Vec<i32> =vec![];
        assert_eq!(remove_duplicates(&nums),0);
    }
    #[test]
    fn test_remove_duplicates_no_duplicates() {
        let mut nums = vec![1, 2, 3, 4, 5];
        assert_eq!(remove_duplicates(&mut nums), 5);
        assert_eq!(nums, vec![1, 2, 3, 4, 5]);
    }


    fn remove_duplicates(list_num: &Vec<i32>) -> i32 {
        if list_num.is_empty() {
            return 0;
        }
        list_num.len() as i32
    }
}

</code></pre>
                <p><i class="fas fa-circle" style="color: green;"></i> Dans ce test, le tableau ne contient aucun doublon. La fonction doit parcourir le tableau, constater qu'aucun élément n'est répété, et donc tous les éléments sont considérés comme uniques. Le nombre d'éléments uniques devrait être égal à la longueur du tableau (dans ce cas, 5). Le tableau lui-même ne doit pas être modifié car aucun élément n'a été retiré.</p>
                <h4>Test avec des doublons (test_remove_duplicates_duplicates_exist) :</h4>

                <pre><code class="language-rust">
#[cfg(test)]
mod tests{
    #[test]
    fn test_remove_duplicates_empty(){
        let nums:Vec<i32> =vec![];
        assert_eq!(remove_duplicates(&nums),0);
    }
    #[test]
    fn test_remove_duplicates_no_duplicates() {
        let mut nums = vec![1, 2, 3, 4, 5];
        assert_eq!(remove_duplicates(&mut nums), 5);
        assert_eq!(nums, vec![1, 2, 3, 4, 5]);
    }
    #[test]
    fn test_remove_duplicates_duplicates_exist() {
        let mut nums = vec![1, 1, 2, 2, 3, 4, 5, 5, 6];
        assert_eq!(remove_duplicates(&mut nums), 6);
        assert_eq!(nums, vec![1, 2, 3, 4, 5, 6]);
    }

     fn remove_duplicates(list_num: &mut Vec<i32>) -> i32 {
        if list_num.is_empty() {
            return 0;
        }
        let mut k = 1;
        let len_list=   list_num.len();
        for i in 1..len_list {
            if list_num[i] != list_num[k - 1] {
                list_num[k] = list_num[i];
                k += 1;
            }
        }
        list_num.drain(k..=len_list-1);
        k as i32
    }
}

</code></pre>
                <p><i class="fas fa-circle" style="color: green;"></i>
                    Ce test vérifie le cas où des doublons existent dans le tableau. La fonction doit parcourir le tableau et éliminer les doublons, ne conservant qu'une seule occurrence de chaque élément. Le nombre d'éléments uniques devrait être égal au nombre de différentes valeurs présentes dans le tableau, dans ce cas, 6. Le tableau doit être modifié pour ne contenir que les éléments uniques dans le même ordre relatif qu'ils apparaissent initialement.                </p>
                <h4>Test avec que des doublons (test_remove_duplicates_all_duplicates) :</h4>

                <pre><code class="language-rust">
#[cfg(test)]
mod tests{
    #[test]
    fn test_remove_duplicates_empty(){
        let nums:Vec<i32> =vec![];
        assert_eq!(remove_duplicates(&nums),0);
    }
    #[test]
    fn test_remove_duplicates_no_duplicates() {
        let mut nums = vec![1, 2, 3, 4, 5];
        assert_eq!(remove_duplicates(&mut nums), 5);
        assert_eq!(nums, vec![1, 2, 3, 4, 5]);
    }
    #[test]
    fn test_remove_duplicates_duplicates_exist() {
        let mut nums = vec![1, 1, 2, 2, 3, 4, 5, 5, 6];
        assert_eq!(remove_duplicates(&mut nums), 6);
        assert_eq!(nums, vec![1, 2, 3, 4, 5, 6]);
    }
    #[test]
    fn test_remove_duplicates_all_duplicates() {
        let mut nums = vec![1, 1, 1, 1, 1];
        assert_eq!(remove_duplicates(&mut nums), 1);
        assert_eq!(nums, vec![1]);
    }
     fn remove_duplicates(list_num: &mut Vec<i32>) -> i32 {
        if list_num.is_empty() {
            return 0;
        }
        let mut k = 1;
        let len_list=   list_num.len();
        for i in 1..len_list {
            if list_num[i] != list_num[k - 1] {
                list_num[k] = list_num[i];
                k += 1;
            }
        }
        list_num.drain(k..=len_list-1);
        k as i32
    }
}

</code></pre>
                <p><i class="fas fa-circle" style="color: green;"></i>
                    Dans ce test, tous les éléments du tableau sont des doublons. La fonction devrait donc les éliminer et retourner que 1 élément unique, puisque le premier élément est conservé.
                </p>
                <ol>
                    <li>
                        Cette fonction commence par vérifier si le vecteur est vide, auquel cas elle retourne simplement 0 car il n'y a aucun élément unique à retirer. Ensuite, elle initialise un indice k à 1 et parcourt le vecteur à partir de l'indice 1 jusqu'à la fin. Pour chaque élément, elle le compare avec l'élément précédent conservé (à l'indice k - 1). Si l'élément est différent, elle le conserve et incrémente k pour pointer vers la prochaine position pour un élément unique. À la fin de la boucle, k représente le nombre d'éléments uniques dans le vecteur.
                    </li>
                    <li>
                        Ensuite, la fonction utilise la méthode drain() pour retirer les éléments en excès du vecteur à partir de l'indice k, car ils sont considérés comme des doublons. Enfin, elle retourne k converti en entier signé, qui représente le nombre d'éléments uniques restants dans le vecteur après la suppression des doublons.
                    </li>
                    <li>
                        Cette implémentation est concise, efficace et respecte les exigences du problème. Elle garantit que le vecteur est modifié en place et que l'ordre relatif des éléments est préservé. En conclusion, le code final de la fonction remove_duplicates offre une solution élégante et fonctionnelle pour la suppression des doublons dans un vecteur en Rust.
                    </li>
                </ol>



            </div>
        </div>
    </div>
</article>
<!-- Footer-->
<footer class="border-top">
    <div class="container px-4 px-lg-5">
        <div class="row gx-4 gx-lg-5 justify-content-center">
            <div class="col-md-10 col-lg-8 col-xl-7">
                <ul class="list-inline text-center">

                    <li class="list-inline-item">
                        <a href="https://github.com/specialjcg/">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                        </a>
                        <a href="http://linkedin.com/in/gouleaujeancharles/">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                                    </span>
                        </a>
                    </li>
                </ul>
                <div class="small text-center text-muted fst-italic">Copyright &copy; Your Website 2023</div>
            </div>
        </div>
    </div>
</footer>

<!-- Bootstrap core JS-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Core theme JS-->
<script src="js/scripts.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>
